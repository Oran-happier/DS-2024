#pragma once
#define _CRT_SECURE_NO_WARNINGS ;
#include "Vector.h"
#include <string.h>
#include <cstdint>
#include <cmath>
#define N_OPTR 9 // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿?
typedef enum
{
	ADD,
	SUB,
	MUL,
	DIV,
	POW,
	FAC,
	L_P,
	R_P,
	EOE
} Operator; // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿?
// ï¿½Ó¡ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ë¡ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ë·ï¿½ï¿½ï¿½ï¿½×³Ë¡ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Å¡ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Å¡ï¿½ï¿½ï¿½Ê¼ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö¹ï¿½ï¿½

void append(char *&RPN, float tp);
float calcu(float p1, char op, float p2);
float calcu(char op, float p);
float evaluate(char *S, char *RPN); // ï¿½ï¿½ï¿½ï¿½Ê½ï¿½ï¿½Öµï¿½ï¿½ï¿½æ²¨ï¿½ï¿½ï¿½ï¿½RPNï¿½ï¿½
char priority(char tp, char s);
int opIndex(char op);
const char pri[N_OPTR][N_OPTR] =
	{
		/*              |-------------------- ï¿½ï¿½ Ç° ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ --------------------| */
		/*              +      -      *      /      ^      !      (      )      \0 */
		/* --  + */ '>', '>', '<', '<', '<', '<', '<', '>', '>',
		/* |   - */ '>', '>', '<', '<', '<', '<', '<', '>', '>',
		/* Õ»  * */ '>', '>', '>', '>', '<', '<', '<', '>', '>',
		/* ï¿½ï¿½  / */ '>', '>', '>', '>', '<', '<', '<', '>', '>',
		/* ï¿½ï¿½  ^ */ '>', '>', '>', '>', '>', '<', '<', '>', '>',
		/* ï¿½ï¿½  ! */ '>', '>', '>', '>', '>', '>', ' ', '>', '>',
		/* ï¿½ï¿½  ( */ '<', '<', '<', '<', '<', '<', '<', '~', ' ',
		/* |   ) */ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
		/* -- \0 */ '<', '<', '<', '<', '<', '<', '<', ' ', '~'};
// void convert(Stack<char>& S, __int64 n, int base);//ï¿½ï¿½ï¿½ï¿½×ªï¿½ï¿½ï¿½ã·¨ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
// bool paren(const char exp[], Rank lo, Rank hi);//ï¿½ï¿½ï¿½ï¿½Æ¥ï¿½ï¿½ï¿½ã·¨ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½

template <typename T>
class Stack : public Vector<T>
{
public:															 // ï¿½ï¿½ï¿½ï¿½Ê½ï¿½Ó¿Ú£ï¿½Ö±ï¿½ï¿½Ê¹ï¿½ï¿½
	void push(T const &e) { Vector<T>::insert(e); }				 // ï¿½ï¿½Õ»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ôªï¿½ï¿½ï¿½ï¿½Îªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä©Ôªï¿½Ø²ï¿½ï¿½ï¿½
	T pop() { return Vector<T>::remove(Vector<T>::size() - 1); } // ï¿½ï¿½Õ»
	T &top() { return (*this)[Vector<T>::size() - 1]; }			 // È¡ï¿½ï¿½ï¿½ï¿½Ö±ï¿½Ó·ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä©Ôªï¿½ï¿½

	friend void readNumber(char *S, Stack<float> &opnd);
};

void convert(Stack<char> &S, __int64_t n, int base)
{
	// ï¿½Â½ï¿½ï¿½ï¿½ï¿½Âµï¿½ï¿½ï¿½Î»ï¿½ï¿½ï¿½ï¿½
	static char digit[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
	while (n > 0)
	{
		int remainder = (int)(n % base);
		S.push(digit[remainder]); // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ç°Î»ï¿½ï¿½ï¿½ï¿½Õ»
		n /= base;				  // ï¿½ï¿½ï¿½ï¿½ÎªÈ¥Î»ï¿½ï¿½
	}
} // ï¿½ï¿½ï¿½ï¿½ï¿½Î³ï¿½ï¿½ÂµÄ½ï¿½ï¿½Æ£ï¿½ï¿½Ô¶ï¿½ï¿½ï¿½ï¿½Â±ï¿½ï¿½ï¿½ï¿½ï¿½Õ»ï¿½ï¿½

bool paren(const char exp[], Rank lo, Rank hi)
{
	// ï¿½ï¿½ï¿½ï¿½Ê½ï¿½ï¿½ï¿½ï¿½Æ¥ï¿½ï¿½ï¿½ï¿½,ï¿½É¼ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿?
	Stack<char> S;					// Ê¹ï¿½ï¿½Õ»ï¿½ï¿½Â¼ï¿½Ñ·ï¿½ï¿½Öµï¿½ï¿½ï¿½Î´Æ¥ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿?
	for (Rank i = lo; i <= hi; i++) /* ï¿½ï¿½Ò»ï¿½ï¿½éµ±Ç°ï¿½Ö·ï¿? */
		switch (exp[i])
		{ // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö±ï¿½Ó½ï¿½Õ»;ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Õ»ï¿½ï¿½Ê§ï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½Ê½ï¿½Ø²ï¿½Æ¥ï¿½ï¿?
		case '(':
		case '[':
		case '{':
			S.push(exp[i]);
			break;
		case ')':
			if ((S.empty()) || ('(' != S.pop()))
				return false;
			break;
		case ']':
			if ((S.empty()) || ('[' != S.pop()))
				return false;
			break;
		case '}':
			if ((S.empty()) || ('{' != S.pop()))
				return false;
			break;
		default:
			break; // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö·ï¿½Ò»ï¿½Éºï¿½ï¿½ï¿½
		}
	return S.empty(); // ï¿½ï¿½ï¿½ï¿½Õ»ï¿½ï¿½,ï¿½ï¿½ï¿½Ò½ï¿½ï¿½ï¿½Æ¥ï¿½ï¿½
}

float evaluate(char *S, char *RPN)
{ // ï¿½ï¿½(ï¿½ï¿½ï¿½Þ³ï¿½ï¿½×¿Õ¸ï¿½ï¿?)ï¿½ï¿½ï¿½ï¿½Ê½sï¿½ï¿½Öµ,ï¿½ï¿½×ªï¿½ï¿½Îªï¿½æ²¨ï¿½ï¿½Ê½RPN
	Stack<float> opnd;
	Stack<char> optr; // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Õ»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Õ?
	optr.push('\0');  // Î²ï¿½Ú±ï¿½'\0'Ò²ï¿½ï¿½ÎªÍ·ï¿½Ú±ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Õ»
	while (!optr.empty())
	{ // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Õ»ï¿½Ç¿ï¿½Ö?Ç°,ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ê½ï¿½Ð¸ï¿½ï¿½Ö·ï¿?
		if (isdigit(*S))
		{ // ï¿½ï¿½ï¿½ï¿½Ç°ï¿½Ö·ï¿½Îªï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,ï¿½ï¿½
			readNumber(S, opnd);
			append(RPN, opnd.top()); // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿?,ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½RPNÄ©Î²
			S++;
		}
		else // ï¿½ï¿½ï¿½ï¿½Ç°ï¿½Ö·ï¿½Îªï¿½ï¿½ï¿½ï¿½ï¿?,ï¿½ï¿½
			switch (priority(optr.top(), *S))
			{		  // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Õ»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö?ï¿½ï¿½ï¿½ï¿½ï¿½È¼ï¿½ï¿½ßµÍ·Ö±ï¿½ï¿½ï¿½
			case '<': // Õ»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È¼ï¿½ï¿½ï¿½ï¿½ï¿½Ê?
				optr.push(*S);
				S++; // ï¿½ï¿½ï¿½ï¿½ï¿½Æ³ï¿½,ï¿½ï¿½Ç°ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Õ?
				break;
			case '>':
			{ // Õ»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È¼ï¿½ï¿½ï¿½ï¿½ï¿½Ê?,ï¿½ï¿½ÊµÊ©ï¿½ï¿½Ó¦ï¿½Ä¼ï¿½ï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Õ?
				char op = optr.pop();
				append(RPN, op);					  // Õ»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Õ»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½RPNÄ©Î²
				if ('!' == op)						  // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ò»Ôªï¿½ï¿½ï¿½ï¿½ï¿?
					opnd.push(calcu(op, opnd.pop())); // ï¿½ï¿½È¡Ò»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Õ»
				else
				{												  // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½Ôª)ï¿½ï¿½ï¿½ï¿½ï¿?
					float opnd2 = opnd.pop(), opnd1 = opnd.pop(); // È¡ï¿½ï¿½ï¿½ï¿½Ç°ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
					opnd.push(calcu(opnd1, op, opnd2));			  // ÊµÊ©ï¿½ï¿½Ôªï¿½ï¿½ï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½Õ?
				}
				break;
			}
			case '~': // Æ¥ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½(ï¿½ï¿½ï¿½Å»ï¿½\0')Ê±
				optr.pop();
				S++; // ï¿½ï¿½ï¿½ï¿½ï¿½Å²ï¿½×ªï¿½ï¿½ï¿½ï¿½Ò»ï¿½Ö·ï¿½
				break;
			default:
				exit(-1); // ï¿½ï¿½ï¿½ï·¨ï¿½ï¿½ï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö±ï¿½ï¿½ï¿½Ë³ï¿½
			} // switch
	} // while
	return opnd.pop(); // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä¼ï¿½ï¿½ï¿½ï¿½ï¿½
}

float calcu(float p1, char op, float p2)
{
	switch (op)
	{
	case '+':
		return p1 + p2;
	case '-':
		return p1 - p2;
	case '*':
		return p1 * p2;
	case '/':
		return p1 / p2;
	case '^':
		return pow(p1, p2);
	default:
		break;
	}
	return 0.0;
}

float calcu(char op, float p)
{
	float np = 1.0;
	while (p > 1.0)
	{
		np *= p--;
	} // ï¿½ï¿½Êµï¿½ï¿½Ð¡ï¿½ï¿½ï¿½Ä½×³Ë²ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ä£ï¿½ï¿½ï¿½ï¿½Ç¿ï¿½ï¿½Çµï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Êµï¿½ï¿½.0ï¿½ï¿½ï¿½ï¿½Ê½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	return np;
}

char priority(char tp, char s)
{

	return pri[opIndex(tp)][opIndex(s)];
}

int opIndex(char op)
{
	switch (op)
	{
	case '+':
		return ADD;
	case '-':
		return SUB;
	case '*':
		return MUL;
	case '/':
		return DIV;
	case '^':
		return POW;
	case '!':
		return FAC;
	case '(':
		return L_P;
	case ')':
		return R_P;
	case '\0':
		return EOE;
	default:
		break;
	}
	return 0;
}

void readNumber(char *S, Stack<float> &opnd)
{
	opnd.push(*S - '0');
}

void append(char *&RPN, float tp)
{
	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö·ï¿½ï¿½ï¿½ï¿½ï¿?20ï¿½ï¿½ï¿½ÚµÄ´ï¿½Ð¡ï¿½ï¿½ï¿½ï¿½Êµï¿½ï¿½ï¿½Ç²ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È«ï¿½ï¿½
	// ï¿½ï¿½ï¿½ï¿½Òªï¿½ï¿½RPNï¿½ã¹»ï¿½ó£¬²ï¿½È»ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿?
	char newtp[20];
	sprintf(newtp, "%.2f", tp);
	strcat(RPN, newtp);
}
